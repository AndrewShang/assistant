---

copyright:
  years: 2015, 2018
lastupdated: "2018-02-09"

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:tip: .tip}
{:pre: .pre}
{:codeblock: .codeblock}
{:screen: .screen}
{:javascript: .ph data-hd-programlang='javascript'}
{:java: .ph data-hd-programlang='java'}
{:python: .ph data-hd-programlang='python'}
{:swift: .ph data-hd-programlang='swift'}
{:table: .aria-labeledby="caption"}

# ダイアログの概要
{: #dialog-overview}

ダイアログでは、ユーザー入力から検出されたインテントとエンティティーに加えてアプリケーションのコンテキストを使用してユーザーと対話し、最終的に有用な応答を返します。
{: shortdesc}

応答は、例えば「`ガソリンスタンドはどこ?`」のような質問に対する回答であったり、ラジオをオンにするなどのコマンドの実行であったりします。 検出されたインテントとエンティティーだけで正しい応答を導出できる場合もあれば、正しく応答するためにダイアログでユーザーに追加入力を求めなければならない場合もあります。 例えば、ユーザーが`「何か食べられる場所を教えて」`と質問した場合は、レストランに行きたいのかそれとも食料品店に行きたいのか、食事をしたいのかそれともテイクアウトしたいのか、などを明確にする必要があります。テキストによる応答で詳細を尋ね、新たな入力を処理するための子ノードを 1 つ以上作成することができます。

<iframe class="embed-responsive-item" id="youtubeplayer" type="text/html" width="640" height="390" src="https://www.youtube.com/embed/oQUpejt6d84?rel=0" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen> </iframe>

ダイアログは {{site.data.keyword.conversationshort}} ツール内でグラフィカルなツリー構造で表されます。 会話で扱うインテントごとに、インテントを処理するブランチを作成します。 1 つのブランチは複数のノードで構成されます。

## ダイアログ・ノード

各ダイアログ・ノードには、少なくとも 1 つの条件と 1 つの応答が含まれます。

![「If: 条件, Then: 応答」というステートメントを含むボックスにユーザー入力が入ることを示しています。](images/node1-empty.png)

- 条件: ダイアログのこのノードをトリガーするためにユーザー入力に含まれている必要がある情報を指定します。 特定のインテント、エンティティー値、コンテキスト変数値などの情報です。 詳しくは、[条件](dialog-runtime.html#conditions)を参照してください。
- 応答: サービスがユーザーに応答するために使用する発話。 プログラムによるアクションをトリガーするように応答を構成することもできます。 詳しくは、[応答](#responses)を参照してください。

ノードは if/then 構造を持つものと見なすことができます。その条件が true であれば、その応答が返されます。

例えば、サービスの自然言語処理機能が、ユーザー入力に `#cupcake-menu` インテントが含まれていることを検出した場合は、次のノードがトリガーされます。 ノードがトリガーされた結果として、サービスは適切な回答を返します。

![ユーザーがカップケーキのフレーバーを尋ねます。If 条件は #cupcake-menu であり、Then 応答はカップケーキのフレーバーのリストです。](images/node1-simple.png)

単純なユーザー要求であれば、条件と応答を 1 つずつ含む 1 つのノードで処理できます。 しかし、多くの場合、ユーザーはより高度な質問をしたり、より複雑な作業のヘルプを求めたりします。 その場合は、サービスに必要な追加情報を提供するようにユーザーに求める子ノードを追加します。

![ダイアログの最初のノードで、カップケーキの種類としてグルテンフリーとレギュラーのどちらが良いのかを尋ねています。ユーザーの回答に応じて異なる応答を提供するために、子ノードが 2 つあります。](images/node1-children.png)

## ダイアログのフロー

作成したダイアログを、サービスは、ツリーの最初のノードから最後のノードまで処理します。

![3 つのノードの横にある下向き矢印は、ダイアログが最初のノードから最後のノードまで処理されることを示しています](images/node-flow-down.png)

サービスはツリーを上から下に処理し、満たされている条件を検出すると、そのノードをトリガーします。 その次は、トリガーされたノードに移動し、子ノードの条件とユーザー入力を照合します。子ノードをチェックするときにも、最初の子ノードから最後の子ノードまで移動します。

サービスは、ダイアログ・ツリーを最初のノードから最後のノードまでたどります。途中、ノードがトリガーされるたびに、そのノードの最初の子ノードから最後の子ノードまでたどり、また、子ノードがトリガーされるたびに、そのブランチを最後のノードに達するまでたどります。

![矢印 1 は最初のルート・ノードから最後のルート・ノードを指し、矢印 2 はトリガーされたノードの長さを進み、矢印 3 はトリガーされたノードの最初の子ノードから最後の子ノードを指しています。](images/node-flow.png)

ダイアログの作成を始めるには、ツリーに含めるブランチとその配置場所を決める必要があります。 ノードは最初から最後まで評価されるので、ブランチの順序が重要です。入力と一致する条件を持つ最初のルート・ノードが使用されます。つまり、それより後に位置するツリー内のノードはトリガーされません。

サービスがブランチの最後に到達した場合、または、評価対象である現在の子ノードのセットに true と評価される条件がない場合、サービスはツリーの基点にジャンプして戻ります。そしてもう一度、サービスはルート・ノードを最初から最後まで処理します。true と評価される条件がまったくない場合は、ツリー内の最後のノードの応答が返されます。このノードは通常、常に true と評価される特殊な `anything_else` 条件を持ちます。

ノードが処理された後に実行する内容をカスタマイズして、この最初から最後までたどる標準的なフローを中断することができます。例えば、ノードが処理された後に別のノードに直接ジャンプするように、あるノードを構成すると、ジャンプ先のノードより前に位置する他のノードがツリー内にあっても無視することができます。詳しくは、[次の処理の定義](dialog-overview.html#jump-to)を参照してください。

各ノードに構成した脱線設定も、実行時にユーザーがノードを移動する方法に影響します。ほとんどのノードから脱線できるようにした場合、ユーザーは簡単に別のノードにジャンプして戻ることができます。詳しくは、[脱線](dialog-runtime.html#digressions)を参照してください。

## 条件
{: #conditions}

ノード条件により、そのノードを会話で使用するかどうかが決まります。 応答条件により、ユーザーに表示する応答が決まります。

- [条件成果物](dialog-overview.html#condition-artifacts)
- [条件構文の詳細](dialog-overview.html#condition-syntax)
- [条件の使用上のヒント](dialog-overview.html#condition-tips)

### 条件成果物
{: #condition-artifacts}

条件を定義するには、次の成果物を 1 つ以上組み合わせて使用します。

- **コンテキスト変数**: ノードは、指定したコンテキスト変数式が true の場合に使用されます。 `$variable_name:value` または `$variable_name == 'value'` という構文を使用します。 例えば、`$city:Boston` は、`$city` コンテキスト変数に値 `Boston` が含まれているかどうかを検査します。含まれている場合は、ノードまたは応答が処理されます。

  コンテキスト変数値を設定するダイアログ・ノードと同じノードに、そのコンテキスト変数値に基づくノード条件または応答条件を定義しないでください。
  {: tip}

  コンテキスト変数について詳しくは、[コンテキスト変数](dialog-runtime.html#context)を参照してください。

- **エンティティー**: ノードは、ユーザー入力でエンティティー値またはシノニムが認識された場合に使用されます。 構文 `@entity_name` を使用します。例えば、`@city` は、@city エンティティーとして定義されている都市名がユーザー入力に検出されたかどうかを検査します。検出されている場合は、ノードまたは応答が処理されます。

  必ず、エンティティー値もシノニムも認識されないケースを処理するピア・ノードを作成してください。
  {: tip}

  エンティティーについて詳しくは、[エンティティーの定義](entities.html)を参照してください。

- **エンティティー値**: ノードは、ユーザー入力でエンティティー値が検出された場合に使用されます。 構文 `@entity_name:value` を使用して、シノニムではなく、エンティティーの定義済みの値を指定します。例えば、`@city:Boston` は特定の都市名 `Boston` がユーザー入力で検出されたかどうかを検査します。

  エンティティーがキャプチャー・グループを持つパターン・エンティティーである場合は、特定のグループ値との一致がないかを検査できます。例えば、`@us_phone.groups[1] == '617'` という構文を使用できます。
詳しくは、[コンテキスト変数へのパターン・エンティティー値の保管](dialog-runtime.html#context-pattern-entities)を参照してください。

  ピア・ノードで特定の値を指定せずにエンティティーの存在を検査する場合は、必ず、エンティティーの存在のみを検査するピア・ノードより前に、このノード (特定のエンティティー値を検査するノード) を配置してください。そうしないと、このノードは評価されません。
{: tip}

- **インテント**: 最も単純な条件は単一のインテントです。 ノードは、ユーザー入力がそのインテントに対応する場合に使用されます。 構文 `#intent_name` を使用します。例えば、`#weather` は、ユーザー入力で検出されたインテントが `weather` であるかどうかをチェックします。 そうであれば、ノードは処理されます。

  インテントについて詳しくは、[インテントの定義](intents.html)を参照してください。

- **特殊条件**: 一般的なダイアログ機能を実行できるようにサービスに用意されている条件。

| 条件の構文| 説明 |
|----------------------|-------------|
| `anything_else`      | この条件をダイアログの最後で使用して、ユーザー入力が他のどのダイアログ・ノードとも一致しない場合の処理を実行できます。 この条件により、**Anything else** ノードがトリガーされます。|
| `conversation_start` | **welcome** と同じく、この条件はダイアログの最初のターンで true と評価されます。 **welcome** とは異なり、アプリケーションからの最初の要求にユーザー入力が含まれているかどうかにかかわらず、true になります。 **conversation_start** 条件を指定したノードを使用して、ダイアログの開始時にコンテキスト変数を初期化したり他のタスクを実行したりできます。 |
| `false`              | この条件は常に false と評価されます。 開発中のブランチの先頭にこれを使用して、そのブランチが使用されないようにしたり、一般的な機能を提供するノードの条件として使用し、そのノードを **Jump to** アクションのターゲットとしてのみ使用するようにしたりできます。|
| `irrelevant`         | {{site.data.keyword.conversationshort}} サービスがユーザー入力を不適当と判断した場合に、この条件は true と評価されます。 |
| `true`               | この条件は常に true と評価されます。 ノードまたは応答のリストの最後でこれを使用して、それまでの条件と一致しなかったすべての応答をキャッチできます。 |
| `welcome`            | この条件は、アプリケーションからの最初の要求にユーザー入力が含まれていない場合にのみ、ダイアログの最初のターン (ダイアログの開始時) に true と評価されます。 2 ターン目以降では false と評価されます。 この条件により、**Welcome** ノードがトリガーされます。 一般的に、この条件を持つノードはユーザーへのあいさつ文 (例えば、`「ピザ注文アプリへようこそ」` のようなメッセージ) を表示するために使用します。|
{: caption="特殊な条件" caption-side="top"}

### 条件構文の詳細
{: #condition-syntax}

条件で有効な式を作成するには、次のいずれかの構文オプションを使用します。

- インテント、エンティティー、コンテキスト変数を参照する省略表現。 [オブジェクトへのアクセスと評価](expression-language.html)を参照してください。

- Spring Expression (SpEL) 言語。実行時のオブジェクト・グラフの照会と操作をサポートする式言語です。 詳しくは、[Spring Expression Language (SpEL) 言語![外部リンク・アイコン](../../icons/launch-glyph.svg "外部リンク・アイコン")](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html){: new_window}を参照してください。

正規表現を使用して、条件として使用する値を検査できます。例えば、`String.find` メソッドを使用して、一致する文字列を検索できます。 詳しくは、[メソッド](dialog-methods.html)を参照してください。

### 条件の使用上のヒント
{: #condition-tips}

- **特殊文字を含む値があるかどうかを検査する**: エンティティーまたはコンテキスト変数に、アポストロフィ (') などの特殊文字を含む値が入っているかどうかを検査する場合は、検査する値を括弧で囲む必要があります。例えば、エンティティーまたはコンテキスト変数に名前 `O'Reilly` が含まれているかどうかを検査するには、名前を括弧で囲む必要があります。

  `@person:(O'Reilly)` および `$person:(O'Reilly)`

  サービスは、これらの省略表現を以下の完全な SpEL 式に変換します。

  `entities['person']?.contains('O''Reilly')` および `context['person'] == 'O''Reilly'`

  **注**: SpEL では 2 つ目のアポストロフィを使用して、名前の中の単一のアポストロフィをエスケープします。

- **数値があるかどうかを検査する**: 数値を使用する場合は、変数に値があることを確認してください。値がない変数は、数値比較でヌル値 (0) として扱われます。

  例えば、`@price < 100` という条件で変数の値をチェックし、@price エンティティーがヌルである場合、 0 は 100 未満であるため、価格が設定されていなかったにもかかわらず、条件が `true` と評価されます。 ヌル変数のチェックを回避するには、`@price AND @price < 100` のような条件を使用します。 `@price` に値がなければ、この条件は正しく false という結果を返します。

- **特定のインテント名パターンを持つインテントがあるかどうかを検査する**: パターンに一致するインテントを探す条件を使用できます。例えば、「User_」で始まるインテント名のインテントを見つけるには、条件で次のような構文を使用します。

  `intents[0].intent.startsWith("User_")`

  ただし、この場合は、信頼度が 0.2 未満であっても、検出されたすべてのインテントが対象になります。また、信頼度スコアに基づいて Watson が無関係と見なすインテントが返されていないことも検査してください。そのためには、条件を次のように変更します。

  `!irrelevant && intents[0].intent.startsWith("User_")`

- **ファジー・マッチングがエンティティー認識に与える影響**: エンティティーを条件として使用し、ファジー・マッチングを有効にした場合、`@entity_name` が true と評価されるのは、一致の信頼度が 30% より大きい (`@entity_name.confidence > .3`) 場合のみです。
- **入力に含まれている複数のエンティティーの処理**: あるエンティティー・タイプの最初に検出されたインスタンスの値のみを評価するには、`@entity:(specific-value)` ではなく、`@entity == 'specific-value'` という形式の構文を使用します。

  例えば、`@appliance == 'エアコン'` を使用すると、最初に検出された `@appliance` エンティティーの値のみが評価されます。 しかし、`@appliance:(エアコン)` を使用すると、`entity['appliance'].contains('エアコン')` に展開されます。これは、ユーザー入力に「エアコン」という値の `@appliance` エンティティーが 1 つ以上検出されたときに必ず一致します。

## 応答
{: #responses}

ダイアログの応答は、ユーザーへの応答方法を定義するものです。

次のいずれかの応答タイプを使用できます。

- [単純なテキスト応答](#simple-text)
- [条件付き応答](#multiple)
- [複雑な応答](#complex)
- [マルチメディア応答](#multimedia)

### 単純なテキスト応答
{: #simple-text}

テキスト応答を提供する場合は、単に、サービスでユーザーに表示するテキストを入力します。

![ユーザーに「店舗地はどこですか」と尋ねられた場合のダイアログの応答として、「実店舗はありませんが、インターネット接続があれば、どこからでも当店の商品をお買い求めいただけます」と返すノードを示しています。](images/response-simple.png)

応答に E メール・アドレスを含める場合は、アットマーク (`@`) をバックスラッシュ (`\`) でエスケープする必要があります (例: `feedback\@example.com までご意見をお寄せ下さい`)。同様に、応答に番号記号 (`#`) を含める場合も、エスケープする必要があります (例: `当店のロブスター・ロールの売り上げはメイン州で \#1 です`)。 エンティティー名は `@` で始まり、インテント名は `#`で始まります。これらの記号をエスケープすると、サービスが応答テキストを誤って読み取ることがなくなります。
{: tip}

#### バリエーションの追加
{: #variety}

常に同じあいさつと応答を聞かされては、ダイアログ・サービスをよく利用するユーザーがうんざりする可能性があります。  *バリエーション*を応答に追加すると、Conversation が同じ条件に対してさまざまな方法で応答できるようになります。

<iframe class="embed-responsive-item" id="youtubeplayer" type="text/html" width="640" height="390" src="https://www.youtube.com/embed/nAlIW3YPrAs?rel=0" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen> </iframe>

次の例では、店舗地についての質問に対する応答として、サービスが対話ごとに異なる回答を返します。

![ユーザーに「店舗地はどこですか」と尋ねられた場合の応答として、ダイアログに 3 つの異なる応答が定義されているノードを示しています。](images/variety.png)

応答のバリエーションを順番に選択するか、ランダムな順序で選択するかを選択できます。 デフォルトでは、順序付きリストから選択されたかのように、応答は順番に選択されます。

### 条件付き応答
{: #multiple}

1 つのダイアログ・ノードで、条件に応じてさまざまな応答をトリガーすることができます。  このアプローチを使用すると、単一ノードで複数のシナリオに対処できます。

<iframe class="embed-responsive-item" id="youtubeplayer" type="text/html" width="640" height="390" src="https://www.youtube.com/embed/KcvVQAsnhLM?rel=0" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen> </iframe>

このようなノードにもメインの条件があります。それは、そのノードを使用して、ノードに含まれている条件と応答を処理するための条件です。

この例では、サービスは前に収集したユーザーの現在地についての情報を基に応答を調整し、ユーザーの最寄りの店舗に関する情報を提供しています。 ユーザーから収集した情報の保管方法について詳しくは、[コンテキスト変数](dialog-runtime.html#context)を参照してください。

![「店舗地はどこですか」とユーザーから尋ねられた場合のダイアログの応答として、州の場所を示す $state コンテキスト変数の情報を使用した条件に応じて、3 つの異なる応答を返すノードを示しています。](images/multiple-responses.png)

この単一のノードは、ノード 4 つ分に相当する機能を備えています。

条件付き応答をノードに追加するには、**「カスタマイズ (Customize)」**をクリックしてから、**「複数の応答 (Multiple responses)」**をクリックして **「オン (On)」**に切り替えます。

ノード内の条件は、ノードと同様に順序どおりに評価されます。  必ず、条件と応答を正しい順序でリストしてください。  順序を変更する必要がある場合は、条件を選択して、表示された矢印を使用してリスト内で条件を上下に移動します。コンテキストを更新するには、個々の応答用の JSON エディターで更新する必要があります。すべての応答に使用できる共通の JSON エディターはありません。**Jump to** アクションをノードに関連付けた場合、いずれかの応答が処理されるまでジャンプは行われません。
{: tip}

### 複雑な応答
{: #complex}

より複雑な応答を指定するには、JSON エディターを使用して、`"output":{}` プロパティーで応答を指定します。

応答にコンテキスト変数の値を含めるには、`$variable-name` という構文を使用して指定します。 詳しくは、[コンテキスト変数](dialog-runtime.html#context)を参照してください。

```json
{
  "output": {
    "text": "Hello $user"
  }
}
```
{: codeblock}

複数の文を別々の行に表示するには、出力を JSON 配列として定義します。

```json
{
  "output": {
    "text": ["Hello there.", "How are you?"]
  }
}
```
{: codeblock}

最初の文が表示された行の下に、2 番目の文が別の行として表示されます。

より複雑な動作を実装するには、出力テキストを複合 JSON オブジェクトとして定義します。 例えば、JSON 出力で複合オブジェクトを使用して、ノードに応答のバリエーションを追加する動作を模倣できます。 この複合オブジェクトには、次のプロパティーを指定できます。

- **values**: このダイアログ・ノードから返せる複数のバージョンの出力テキストを保持する文字列の JSON 配列。 配列内の値が返される順序は、属性 `selection_policy` に応じて異なります。

- **selection_policy**: 以下の値が有効です。

    - **random**: `values` 配列から出力テキストがランダムに選択されます。同じ値が連続で選択されることはありません。 例えば、output.text に 3 つの値が含まれているとします。 最初の 3 回はランダム値が選択されますが、同じ値が連続することはありません。 すべての出力値が選択された後、新たな値がランダムに選択され、プロセスが繰り返されます。

        ```json
        {
            "output":{
                "text":{
                    "values":["Hello.","Hi.","Howdy!"],
                    "selection_policy":"random"
                }
            }
        }
        ```
        {: codeblock}

    システムは、この 3 つのあいさつから 1 つをランダムに選択して返します。 次に応答がトリガーされたときには、リストの別のあいさつが表示されます。 使用したあいさつを意図的に繰り返さない場合を除き、あいさつはもう一度ランダムに選択されます。

    - **sequential**: システムは、ダイアログ・ノードが最初にトリガーされたときには最初の出力テキストを返し、2 回目にトリガーされたときには 2 番目の出力テキストを返す、というように処理します。

        ```json
        {
            "output":{
                "text":{
                    "values":["Hello.","Hi.","Howdy!"],
                    "selection_policy":"sequential"
                }
            }
        }
        ```
        {: codeblock}

- **append**: 配列に値を追加するか、配列の値を新しい値で上書きするかを指定します。 false に設定すると、前に実行されたダイアログ・ノードで収集された出力が、この特定のノードのテキストで上書きされます。

    ```json
    {
        "output":{
            "text":{
                "values": ["Hello."],
                "append":false
            }
        }
    }
    ```
    {: codeblock}

    この場合、他のすべての出力テキストが、この出力テキストで上書きされます。

デフォルトの動作は、`selection_policy = random` と `append = true` が前提です。 values 配列に複数の項目が含まれている場合、出力テキストはそれらの要素からランダムに選択されます。

### マルチメディア応答
{: #multimedia}

{{site.data.keyword.conversationshort}} コネクターを使用して、ダイアログを Slack または Facebook Messenger と統合する場合は、クリック可能なボタンなどのマルチメディア要素や対話要素を含むダイアログ・ノード応答を指定できます。

詳しくは、[マルチメディア応答](dialog-multimedia.html)を参照してください。

## 次の処理の定義
{: #jump-to}

指定された応答を返した後に、次のいずれかの処理を行うようにサービスに命令できます。

- **ユーザー入力を待機する (Wait for user input)**: サービスは、ユーザーが応答に対して新しい入力を提供するまで待機します。例えば、応答でユーザーに「はい」または「いいえ」で回答する質問をしたとします。 このダイアログは、ユーザーが回答を入力するまで進行しません。
- **ユーザー入力をスキップする (Skip user input)**: このオプションは、ユーザー入力を待たずに現在のノードの最初の子ノードに直接ジャンプする場合に使用します。

  **注**: 現在のノードに少なくとも 1 つの子ノードが存在しないと、このオプションは使用できません。

- **別のダイアログ・ノードにジャンプする (Jump to another dialog node)**: このオプションは、ユーザー入力を待たずに、会話をまったく別のダイアログ・ノードに直接移動する場合に使用します。例えば、*Jump to* アクションを使用して、ツリー内の複数の場所から共通のダイアログ・ノードにフローを向かわせることができます。

  **注**: ジャンプ先のノードを使用するように Jump to アクションを構成する前に、そのターゲット・ノードが存在している必要があります。

### Jump to アクションの構成
{: #jump-to-config}

別のノードにジャンプする場合は、そのアクションのターゲットが、選択したダイアログ・ノードの**応答**であるのか、それとも**条件**であるのかを指定する必要があります。

- **応答**: ステートメントのターゲットが、選択したダイアログ・ノードの応答セクションである場合は、即時に実行されます。 つまり、選択したダイアログ・ノードの条件をシステムは評価しません。選択したダイアログ・ノードの応答がただちに処理されます。

  複数のダイアログ・ノードをチェーニングする場合は、応答をターゲットにすると便利です。 このダイアログ・ノードの条件が true であったかのように、応答が処理されます。選択したダイアログ・ノードに **Jump to** アクションがもう 1 つ含まれている場合は、そのアクションも即時に実行されます。

- **条件**: ステートメントのターゲットが、選択したダイアログ・ノードの条件セクションである場合、サービスはまず、ジャンプ先ノードの条件が trueと評価されるかどうかをチェックします。
    - 条件が true と評価された場合、システムはターゲット・ノードをただちに処理します。
    - 条件が true と評価されなかった場合、システムはターゲット・ノードの次の兄弟ノードに移動してその条件を評価します。条件が true と評価されるダイアログ・ノードを検出するまで、このプロセスを繰り返します。
    - システムがすべての兄弟ノードを処理し、どの条件も true と評価されなかった場合は、基本フォールバック戦略が使用され、ダイアログ・ツリーの基本レベルでダイアログがノードを評価します。

    ダイアログ・ノードの条件をチェーニングする場合は、条件をターゲットにすると便利です。 例えば、最初に入力に `#turn_on` などのインテントが含まれているかどうかをチェックし、含まれている場合は、入力に `@lights`、`@radio`、`@wipers` などのエンティティーが含まれているかどうかをチェックします。 条件をチェーニングすることで、大規模なダイアログ・ツリーを構成できます。

## 詳細情報

ダイアログで使用する式言語、メソッド、システム・エンティティー、およびその他の役立つ詳細情報については、ナビゲーション・ペインの**「リファレンス」**セクションを参照してください。
