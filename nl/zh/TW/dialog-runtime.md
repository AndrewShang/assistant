---

copyright:
  years: 2015, 2018
lastupdated: "2018-02-16"

---

{:shortdesc: .shortdesc}
{:new_window: target="_blank"}
{:tip: .tip}
{:pre: .pre}
{:codeblock: .codeblock}
{:screen: .screen}
{:javascript: .ph data-hd-programlang='javascript'}
{:java: .ph data-hd-programlang='java'}
{:python: .ph data-hd-programlang='python'}
{:swift: .ph data-hd-programlang='swift'}

# 對話處理方式
{: #dialog-runtime}

瞭解人員在執行時期與已部署的 {{site.data.keyword.conversationshort}} 服務實例互動時，如何處理對話。
{: shortdesc}

## 對話呼叫的結構
{: message-anatomy}

每一個使用者詞語都會以 /message API 呼叫形式傳遞至對話。這包含使用者所製作的詞語，用於回覆來自要求他們提供相關資訊之對話的提示。部分訂閱方案包含一定數量的 API 呼叫次數，以協助瞭解呼叫的構成成分。單一 /message API 呼叫相當於單一對話開啟，其包含使用者的輸入以及對話的對應回應。

/message API 呼叫要求及回應的內文包含下列物件：

- `context`：包含要持續保存的變數。若要將資訊從某個呼叫傳遞至下一個呼叫，應用程式開發人員必須在每一個後續 API 呼叫中傳遞前一個 API 呼叫的回應環境定義。例如，對話可以收集使用者名稱，然後在後續節點中依名稱來參照使用者。

  ```json
  {
    "context" : {
            "user_name" : "<? @sys-person.literal ?>"
    }
  ```
  {: codeblock}

  如需相關資訊，請參閱[跨對話開啟保留資訊](dialog-runtime.html#context)。

- `input`：使用者所提交的字串。字串最多可以包含 2,048 個字元。

  ```json
  {
    "input": {
      "text" : "Where's your nearest store?"
    }
  ```
  {: codeblock}

- `output`：向使用者顯示的對話回應。您可以使用此區段來定義不要持續保存的物件（例如變數）。例如，如果您要永久地刪除名為 `temp` 且定義在對話中其他位置的環境定義變數，則可以使用下列表示式來進行此作業。

  ```json
  {
  "output": {
    "text" : {},
    "deleted_variable" : "<? context.remove('temp') ?>"
  ```
  {: codeblock}

  如需輸出物件的相關資訊，請參閱[複式回應](dialog-overview.html#complex)。

您可以從 [API 參考資料 ![外部鏈結圖示](../../icons/launch-glyph.svg "外部鏈結圖示")](https://www.ibm.com/watson/developercloud/conversation/api/v1/){: new_window} 進一步瞭解 /message API 呼叫。

## 跨對話開啟保留資訊
{: #context}

對話是無狀態的，表示它不會在與使用者的不同互動之間保留資訊。應用程式開發人員負責維護應用程式所需的任何持續性資訊。應用程式必須尋找環境定義物件，並將其儲存至訊息 API 回應中，以及使用交談流程中所提出的下一個 /message API 要求來將它傳入環境定義物件。

保留資訊的最簡單方式是在用戶端應用程式（例如，Web 瀏覽器）中將整個環境定義物件儲存至記憶體中。因為應用程式變得更為複雜，或者，如果需要傳遞及儲存個人識別資訊，則您可以儲存及擷取資料庫中的資訊。

應用程式可以將資訊傳遞給對話，而對話可以更新此資訊，並將它傳回給應用程式或後續節點。對話的作法是使用環境定義變數。

環境定義變數是您在節點中定義的變數，並選擇性地指定其預設值。其他節點或應用程式邏輯可以隨後設定或變更環境定義變數的值。

環境定義變數值的條件設定方式是從對話節點條件中參照環境定義變數以判斷是否執行節點。而且，您可以從對話節點回應條件中參照環境定義變數，以根據外部服務或使用者所提供的值來顯示不同的回應。

### 從應用程式傳遞環境定義
{: #context-from-app}

設定環境定義變數並將環境定義變數傳遞給對話，即可將資訊從應用程式傳遞給對話。

例如，您的應用程式可以設定 $time_of_day 環境定義變數，並將它傳遞給對話，而此對話可以使用該資訊來修改向使用者顯示的問候語。

![顯示 Welcome 節點，其使用回應條件來檢查從應用程式傳遞給對話的 $time_of_day 環境定義變數值。](images/set-context.png)

在此範例中，對話知道應用程式將變數設為下列其中一個值：*morning*、*afternoon* 或 *evening*。它可以檢查每一個值，並視呈現的值傳回適當的問候語。如果未傳遞變數，或變數的值不符合其中一個預期值，則會向使用者顯示更通用的問候語。

### 將環境定義從節點傳遞至節點
{: #context-node-to-node}

對話也可以新增環境定義變數以在不同的節點之間傳遞資訊，或是更新環境定義變數的值。對話詢問並取得使用者的相關資訊時，可以追蹤資訊，而且稍後可以在交談中進行參照。

例如，在某個節點中，您可能會詢問使用者的名稱，並在後面的節點中，依名稱來處理使用者。

![顯示簡介節點，其詢問使用者的名稱，並將名稱儲存為環境定義變數。下一個節點會使用 $username 環境定義變數，依名稱來參照使用者。](images/set-context-username.png)

在此範例中，如果使用者提供名稱，則會使用系統實體 @sys-person 從輸入中擷取使用者名稱。在 JSON 編輯器中，會定義 username 環境定義變數，並將其設為 @sys-person 值。在後續節點中，回應中會包含 $username 環境定義變數，以依名稱來處理使用者。

## 定義環境定義變數
{: #context-var-define}

使用下列其中一個編輯器來定義變數的名稱/值配對，即可定義環境定義變數：

- **環境定義編輯器**：顯示節點編輯視圖中可填入環境定義變數名稱及值資訊的**變數**欄位及對應**值**欄位。

  **附註**：在您新增的節點中會自動顯示這些欄位。對於使用舊版服務所建立的節點，您必須開啟環境定義編輯器來新增這些欄位。

- **JSON 編輯器**：開啟時，可檢視與傳送至 {{site.data.keyword.conversationshort}} 服務的 /message API 要求一起傳遞的基礎 JSON 內容。將名稱/值配對新增至 JSON 內文的 `"context":{}` 區段，即可定義環境定義變數。

名稱/值配對必須符合以下需求：

- `name` 可以包含任何大寫和小寫英文字母、數值字元 (0-9) 及底線。

  **附註**：您可以在名稱中包含其他字元（例如句點及連字號）。不過，如果您這樣做，則每次後續參照變數時都必須使用下列其中一種方法：

  - **context['variable-name']**

      完整 SpEL 表示式語法。
  - **$(variable-name)**

      以括弧括住變數名稱的速記語法。
    如需詳細資料，請參閱[存取及評估物件](expression-language.html#shorthand-syntax-for-context-variables)。

- `value` 可以是任何支援的 JSON 類型，例如簡單字串變數、數字或 JSON 陣列。當您使用 JSON 編輯器來定義環境定義變數時，也可以將 JSON 物件指定為值。

下表顯示在環境定義變數編輯器欄位中如何定義名稱/值配對：

| 變數           | 值                 |
|:---------------|--------------------|
| dessert        | cake               |
| toppings_array | ["onion","olives"] |
| age            | 18                 |

下列 JSON 範例定義 $dessert 字串、$toppings_array 陣列及 $age 數字環境定義變數的值：

```json
{
  "context": {
    "dessert": "cake",
    "toppings_array": ["onion", "olives"],
    "age": 18
  }
}
```
{: codeblock}

若要定義環境定義變數，請完成下列步驟：

1.  在節點的區段中定義環境定義變數，以代表要在對話節點評估期間設定變數的時間。

    **附註**：針對此節點所定義的全部現有環境定義變數值都會顯示在一組對應的**變數**及**值**欄位中。如果您不希望它們顯示在節點的編輯視圖中，則必須關閉環境定義編輯器。您可以從用來開啟它的相同功能表中關閉編輯器；下列步驟說明如何存取功能表。

    - 若要新增在處理節點回應之後所設定或變更的環境定義變數，請將環境定義變數新增至回應區段。

      按一下與回應相關聯的**選項** ![進階回應](images/kabob.png) 圖示，然後選取下列其中一個選項來選擇編輯器：

      - **開啟 JSON 編輯器**
      - **開啟環境定義編輯器**

      ![顯示如何存取與標準節點回應相關聯的 JSON 編輯器。](images/contextvar-json-response.png)

      如果節點的**多個回應**設定是**開啟**，則您必須先按一下**編輯回應** ![編輯回應](images/edit-slot.png) 圖示。

      ![顯示如何存取與已啟用多個條件式回應的標準節點相關聯的 JSON 編輯器。](images/contextvar-json-multi-response.png)

    - 若要新增在符合空位條件之後所設定或更新的環境定義變數，請按一下**編輯空位** ![編輯回應](images/edit-slot.png) 圖示。從*配置空位* 視圖標頭的**選項** ![進階回應](images/kabob.png) 功能表中，按一下**開啟 JSON 編輯器**。（如需空位的相關資訊，請參閱[使用空位收集資訊](dialog-slots.html)。）

      **附註**：目前沒有方法可以使用環境定義編輯器來定義在這階段的對話節點評估期間所設定的環境定義變數。

      ![顯示如何存取與空位條件相關聯的 JSON 編輯器。](images/contextvar-json-slot-condition.png)

    - 若要新增在符合空位的回應條件之後所處理的環境定義變數，請按一下**編輯空位** ![編輯回應](images/edit-slot.png) 圖示。按一下**選項** ![進階回應](images/kabob.png) 圖示，然後選取**啟用條件式回應**。按一下要用來建立與環境定義變數之關聯的回應旁的**編輯回應** ![編輯回應](images/edit-slot.png) 圖示。按一下回應區段中的**選項** ![進階回應](images/kabob.png) 圖示，然後選取下列其中一個選項來選擇編輯器：

      - **開啟 JSON 編輯器**
      - **開啟環境定義編輯器**

      ![顯示如何存取與空位條件式回應相關聯的 JSON 編輯器。](images/contextvar-json-slot-multi-response.png)
1.  若要在環境定義編輯器中定義環境定義變數，請將變數名稱/值配對新增至**變數**及**值**欄位。
1.  若要在 JSON 編輯器中定義環境定義變數，請完成下列其他步驟：

    - 新增 `"context":{}` 區塊（如果不存在的話）。

      ```json
      {
        "context":{},
      "output":{}
    }
    ```
      {: codeblock}

    - 在環境定義區塊中，針對您要定義的每一個環境定義變數，新增一個名稱/值配對。

      ```json
      {
            "context":{
      "name": "value"
    },
        "output": {}
      }
      ```
      {: codeblock}

    在此範例中，會將名為 `new_variable` 的變數新增至已包含變數的環境定義區塊。

    ```json
    {
          "context":{
      "existing_variable": "value",
        "new_variable":"value"
      }
    }
    ```
    {: codeblock}

    隨後，若要參照環境定義變數，請使用語法 `$name`，其中 *name* 是已定義之環境定義變數的名稱。例如，`$new_variable`。

## 一般環境定義變數作業
{: #context-common-tasks}

若要儲存使用者所提供的整個字串作為輸入，請使用 `input.text`：

| 變數     | 值               |
|----------|------------------|
| repeat   | `<?input.text?>` |

```json
{
  "context": {
    "repeat": "<?input.text?>"
      }
    }
```
{: codeblock}

若要將實體的值儲存在環境定義變數，請使用下列語法：

| 變數     | 值               |
|----------|------------------|
| place    | @place           |

```json
{
  "context": {
    "place": "@place"
      }
    }
```
{: codeblock}

您可以使用任一編輯器將 JSON 物件新增至環境定義變數。下列表示式定義包含這組 first 及 last 值（共同形成人員的全名）的 full_name 物件。

| 變數          | 值               |
|---------------|------------------|
| full_name     | { "first":"Paul", "last":"Smith" } |

```json
{
  "context": {
    "full_name": {
      "first":"Paul",
      "last":"Smith"
      }
  }
}
```
{: codeblock}

如果您在回應中指定 `$full_name.first`，則會顯示 `Paul`。

若要儲存從使用者輸入中擷取的字串值，您可以包含 SpEL 表示式，以使用擷取方法將正規表示式套用至使用者輸入。下列表示式會擷取使用者輸入中的數字，並將它儲存至 `$number` 環境定義變數。

| 變數     | 值                                  |
|----------|-------------------------------------|
| 數字   | `<?input.text.extract('[\d]+',0)?>` |

```json
{
  "context": {
   "number": "<?input.text.extract('[\\d]+',0)?>"
  }
}
```
{: codeblock}

當您在 JSON 編輯器中定義正規表示式時，必須使用另一個反斜線 (`\\`) 跳出表示式中使用的全部反斜線。在使用環境定義變數編輯器所定義的正規表示式中，您不需要跳出反斜線。
{: tip}

若要儲存型樣實體的值，請在實體名稱後面加上 .literal。使用此語法可確保使用者輸入中符合所指定型樣的確切文字段會儲存在變數。

| 變數     | 值               |
|----------|------------------|
| email    | @email.literal   |

```json
{
  "context": {
    "email": "<? @email.literal ?>"
  }
}
```
{: codeblock}

## 刪除環境定義變數
{: #context-delete}

若要刪除環境定義變數，請將變數設為空值。

```json
{
  "context": {
    "order_form": null
  }
}
```
{: codeblock}

如果您要移除環境定義變數的全部追蹤，則可以使用 JSONObject.remove(string) 方法將它從環境定義物件中刪除。不過，您必須使用變數來執行移除。在訊息輸出中定義新的變數，因此，不會儲存在現行呼叫外部。

```json
{
  "output": {
    "text" : {},
    "deleted_variable" : "<? context.remove('order_form') ?>"
  }
}
```
{: codeblock}

或者，您可以在應用程式邏輯中刪除環境定義變數。

### 作業順序
{: #context-order-of-ops}

定義環境定義變數的順序不會決定服務的評估順序。服務會隨機評估定義為 JSON 名稱/值配對的變數。請不要在第一個環境定義變數中設定值，並預期可在第二個環境定義變數中使用該值，因為不保證會先執行清單中的第一個環境定義變數，再執行清單中的第二個環境定義變數。例如，請不要使用兩個環境定義變數來實作邏輯，以傳回零與傳遞至節點之某個較高值之間的亂數。

```json
"context": {
    "upper": "<? @sys-number.numeric_value + 1?>",
    "answer": "<? new Random().nextInt($upper) ?>"
}
```
{: codeblock}

使用略為複雜的表示式，避免必須依賴在評估 $answer 環境定義變數之前評估的 $upper 環境定義變數值。

```json
"context": {
    "answer": "<? new Random().nextInt(@sys-number.numeric_value + 1) ?>"
}
```
{: codeblock}

### 儲存型樣實體值
{: #context-pattern-entities}

若要將型樣實體的值儲存在環境定義變數，請在實體名稱後面附加 .literal。使用此語法可確保使用者輸入中符合所指定型樣的確切文字段會儲存在變數。

```json
{
  "context": {
    "email": "<? @email.literal ?>"
  }
}
```
{: codeblock}

若要將單一群組中的文字儲存至已定義群組的型樣實體，請指定您要儲存的群組陣列數目。例如，假設 @phone_number 實體的實體型樣定義如下（請記住，括弧表示型樣群組）：

`\b((958)|(555))-(\d{3})-(\d{4})\b`

若只要儲存使用者輸入中所指定電話號碼的區域碼，您可以使用下列語法：

```json
{
  "context": {
    "area_code": "<? @phone_number.groups[1] ?>"
  }
}
```
{: codeblock}

群組是由用來定義群組型樣的正規表示式所分隔。例如，如果符合實體 `@phone_number` 中所定義型樣的使用者輸入為：`958-234-3456`，則會建立下列群組：

| 群組號碼     | 正規表示式引擎值    | 對話值         | 說明        |
|--------------|---------------------|----------------|-------------|
| groups[0]    | `958-234-3456`      | `958-234-3456` | 第一個群組一律是完整相符字串。|
| groups[1]    | `((958)`l`(555))`   | `958`          | 符合第一個已定義群組的正規表示式的字串，即 `((958)`l`(555))`。|
| groups[2]    | `(958)`             | `958`          | 符合內含為 OR 表示式 `((958)`l`(555))` 中第一個運算元的群組|
| groups[3]    | `(555)`             | `null`         | 不符合內含為 OR 表示式 `((958)`l`(555))` 中第二個運算元的群組|
| groups[4]    | `(\d{3})`           | `234`          | 符合針對群組所定義的正規表示式的字串。|
| groups[5]    | `(\d{4})`           | `3456`         | 符合針對群組所定義的正規表示式的字串。|
{: caption="群組詳細資料" caption-side="top"}

為了協助您解密使用哪個群組號碼來擷取感興趣的輸入區段，您可以一次擷取所有群組的相關資訊。使用下列語法，來建立可傳回所有已分組型樣實體相符項陣列的環境定義變數：

```json
{
  "context": {
    "array_of_matched_groups": "<? @phone_number.groups ?>"
  }
}
```
{: codeblock}

使用「試用」窗格，以輸入部分測試電話號碼值。針對輸入 `958-123-2345`，此表示式會將 `$array_of_matched_groups` 設為 `["958-123-2345","958","958",null,"123","2345"]`。

然後，您可以計算起始於 0 的陣列中的每一個值，以取得其群組號碼。

| 陣列元素值          | 陣列元素號碼         |
|---------------------|----------------------|
| "958-123-2345"      | 0 |
| "958"               | 1 |
| "958"               | 2 |
| null                | 3 |
| "123"               | 4 |
| "2345"              | 5 |
{: caption="陣列元素" caption-side="top"}

例如，若要擷取電話號碼的最後四位數，您很容易確定只需要群組 #5。

若要傳回建立用來代表已分組型樣實體的 JSONArray 結構，請使用下列語法：

```json
{
  "context": {
    "json_matched_groups": "<? @phone_number.groups_json ?>"
  }
}
```
{: codeblock}

此表示式會將 `$json_matched_groups` 設為下列 JSON 陣列：

```json
[
  {"group": "group_0","location": [0, 12]},
  {"group": "group_1","location": [0, 3]},
  {"group": "group_2","location": [0, 3]},
  {"group": "group_3"},
  {"group": "group_4","location": [4, 7]},
  {"group": "group_5","location": [8, 12]}
]
```
{: codeblock}

**附註**：`location` 是實體的內容，而實體使用以零起始的字元偏移來指出偵測到的實體值在輸入文字中的開始及結束位置。

如果您預期在輸入中提供兩個電話號碼，則可以檢查兩個電話號碼。例如，如果存在的話，請使用下列語法來擷取第二個號碼的區域碼。

```json
{
  "context": {
    "second_areacode": "<? entities['phone_number'][1].groups[1] ?>"
  }
}
```
{: codeblock}

如果輸入是 `I want to change my phone number from 958-234-3456 to 555-456-5678`，則 `$second_areacode` 等於 `555`。

## 更新環境定義變數值
{: #context-update}

如果節點設定已設定之環境定義變數的值，則會改寫前一個值。

### 更新複雜 JSON 物件

會改寫所有 JSON 類型的先前值，但 JSON 物件除外。如果 context 變數是複雜類型（例如 JSON 物件），則會使用 JSON 合併程序來更新變數。合併作業會新增任何新定義的內容，並改寫物件的任何現有內容。

在此範例中，會將名稱環境定義變數定義為複雜物件。

```json
{
  "context": {
    "complex_object": {
      "user_firstname" : "Paul",
      "user_lastname" : "Pan",
      "has_card" : false
    }
  }
}
```
{: codeblock}

對話節點會將環境定義變數 JSON 物件更新為下列值：

```json
{
  "complex_object": {
    "user_firstname": "Peter",
    "has_card": true
  }
}
```
{: codeblock}

結果是下列環境定義：

```json
{
  "complex_object": {
    "user_firstname": "Peter",
    "user_lastname": "Pan",
    "has_card": true
  }
}
```
{: codeblock}

如需您可以對物件執行的方法的相關資訊，請參閱[表示式語言方法](dialog-methods.html#objects)。

### 更新陣列

如果對話環境定義資料包含值的陣列，您可以藉由附加值、移除值或取代所有值來更新陣列。

選擇下列其中一個動作來更新陣列。在每一種情況下，我們都會看到在動作前面的陣列、動作，以及套用動作之後的陣列。

- **附加**：若要將值新增至陣列尾端，請使用 `append` 方法。

    針對此「對話」運行環境定義：

    ```json
    {
      "context": {
   "toppings_array": ["onion", "olives"]
      }
    }
    ```
    {: codeblock}

    進行下列更新：

    ```json
    {
      "context": {
   "toppings_array": "<? $toppings_array.append('ketchup', 'tomatoes') ?>"
      }
    }
    ```
    {: codeblock}

    結果：

    ```json
    {
      "context": {
   "toppings_array": ["onion", "olives", "ketchup", "tomatoes"]
      }
    }
    ```
    {: codeblock}

- **移除**：若要移除元素，請使用 `remove` 方法，並在陣列中指定其值或位置。

    - **依值移除**：會依元素值從陣列中移除元素。

        針對此「對話」運行環境定義：

        ```json
        {
          "context": {
   "toppings_array": ["onion", "olives"]
          }
        }
        ```
        {: codeblock}

        進行下列更新：

        ```json
        {
          "context": {
   "toppings_array": "<? $toppings_array.removeValue('onion') ?>"
          }
        }
        ```
        {: codeblock}

        結果：

        ```json
        {
          "context": {
   "toppings_array": ["olives"]
          }
        }
        ```
        {: codeblock}

    - **依位置移除**：會依元素的索引位置從陣列中移除元素。

        針對此「對話」運行環境定義：

        ```json
        {
          "context": {
   "toppings_array": ["onion", "olives"]
          }
        }
        ```
        {: codeblock}

        進行下列更新：

        ```json
        {
          "context": {
   "toppings_array": "<? $toppings_array.remove(0) ?>"
          }
        }
        ```
        {: codeblock}

        結果：

        ```json
        {
          "context": {
   "toppings_array": ["olives"]
          }
        }
        ```
        {: codeblock}

- **改寫**：若要改寫陣列中的值，只需要將陣列設為新值：

    針對此「對話」運行環境定義：

        ```json
        {
          "context": {
   "toppings_array": ["onion", "olives"]
          }
        }
        ```
        {: codeblock}

    進行下列更新：

        ```json
        {
          "context": {
   "toppings_array": ["ketchup", "tomatoes"]
          }
        }
        ```
        {: codeblock}

    結果：

        ```json
        {
          "context": {
   "toppings_array": ["ketchup", "tomatoes"]
          }
        }
        ```
        {: codeblock}

如需您可以對陣列執行的方法的相關資訊，請參閱[表示式語言方法](dialog-methods.html#arrays)。

## 離題
{: #digressions}

如果使用者目前正在進行設計用來處理某個目標的對話流程，而突然地切換主題來起始設計用來處理不同目標的對話流程，則發生離題。對話一律支援使用者變更主題。如果所處理對話分支中沒有任何節點符合使用者最新輸入的目標，則交談會回到樹狀結構，以檢查適當相符項的根節點條件。每個節點可用的離題設定甚至可讓您修改此行為。

使用離題設定，您可以容許交談回到離題發生時所岔斷的對話流程。例如，使用者可能正在訂購新電話，但切換主題詢問有關平板電腦的資訊。您的對話可以回答有關平板電腦的問題，然後將使用者帶回到離開訂購電話過程中的位置。容許發生並返回離題可讓使用者進一步控制執行時的交談流程。他們可以變更主題，並遵循無關主題的整個對話流程，然後回到先前的位置。結果是更接近地模擬人與人交談的對話流程。

下圖使用對話樹狀結構使用者介面的模型來說明離題概念。它會顯示使用者如何與對話節點互動，而對話節點配置成容許返回進行中對話流程的離題。使用者會開始提供預約晚餐所需的資訊。在於 #reservation 節點填入空位的過程中，使用者提出有關素食者菜單選項的問題。對話會回答使用者的新問題，方法是在根節點中尋找可解決它的節點（設定 #cuisine 目的之條件的節點）。然後，它會藉由顯示原始對話節點中下一個空白位置的提示，來返回進行中的交談。

![顯示提供晚餐預約詳細資料的人員詢問素食者選項，得到答案，然後返回提供預約詳細資料。](images/digression.gif)

### 開始之前

在您測試整體對話時，決定何時及何處可以容許離題並從離題返回。下列離題控制項會自動套用至節點。只有在您要變更此預設行為時，才會採取動作。

- 依預設，對話中的每個根節點都配置成容許發生離題。子節點不能是離題的目標。
- 含空位的節點被配置成防止脫離。所有其他節點都配置成容許脫離。不過，在下列情況下，交談不能脫離節點：

  - 如果現行節點的任何子節點包含 `anything_else` 或 `true` 條件

    這些條件的特殊在於一律評估為 true。因為它們的已知行為，通常會將其用於對話中，以強制母節點連續評估特定子節點。在此情況下，為了防止岔斷現有對話流程邏輯，不容許使用離題。您必須先將子節點的條件變更為其他條件，才能啟用脫離這類節點。

  - 如果節點配置成跳至另一個節點，或在處理之後跳過使用者輸入

    節點的最終步驟區段指定在處理節點之後應該發生什麼情況。對話配置成直接跳至另一個節點時，通常確定會遵循特定順序。而且，節點配置成跳過使用者輸入時，相當於強制對話在現行節點之後連續處理第一個子節點。在上述任一情況下，為了防止岔斷現有對話流程邏輯，不容許使用離題。您必須先變更最終步驟區段中所指定的值，才能啟用脫離此節點。

### 自訂離題
{: #enable-digressions}

您未定義離題的開始及結束。使用者可以在執行時完整控制離題流程。您只需要指定每一個節點應該或不應該參與使用者造成的離題。針對每一個節點，您會配置：

- 離題是否可以從節點開始，並離開節點
- 於其他位置開始的離題是否可以設為目標，並進入節點
- 在現行對話流程完成之後，於其他位置開始並進入節點的離題是否必須返回岔斷的對話流程

若要變更個別節點的離題運作，請完成下列步驟：

1.  按一下節點以開啟其編輯視圖。

1.  按一下**自訂**，然後按一下**離題**標籤。

    根據所編輯的節點是根節點、子節點、含子項的節點還是含空位的節點，配置選項會不相同。

    **脫離此節點**

    如果先前所列的情況不適用，則可以進行下列選擇：

    - **所有節點類型**：選擇是否容許使用者在到達現行對話分支尾端之前先脫離現行節點。

    - **所有含子項的節點**：選擇如果已顯示現行節點的回應，而且其子節點伴隨著節點目標，是否要讓交談在離題之後回到現行節點。將*容許在此節點回應之後所觸發的離題返回* 切換開關設為**否**，以避免對話返回現行節點並繼續處理其分支。

      例如，如果使用者詢問 `Do you sell cupcakes?`，並在使用者變更主題之前顯示回應 `We offer cupcakes in a variety of flavors and sizes`，則您可能不會想要對話回到其離開的位置。特別是，如果子節點只處理使用者的可能後續問題，而且可以放心地予以忽略。

      不過，如果節點依賴其子節點來處理問題，則您可能要強制交談返回並繼續處理現行分支中的節點。例如，起始回應可能是 `We offer cupcakes in all shapes and sizes. Which menu do you want to see: gluten-free, dairy-free, or regular?`。如果使用者在此時變更主題，您可能會想要對話返回，讓使用者可以挑選菜單類型，並取得他們想要的資訊。

    - **含空位的節點**：選擇是否要容許使用者在填入所有空位之前先脫離節點。將*容許在填入空位時脫離* 切換開關設為**是**，以啟用脫離。

      如果已啟用，則交談從離題返回時，會顯示下一個未填入空位的提示，鼓勵使用者繼續提供資訊。如果已停用，則會忽略使用者所提交且未包含可填入空位之值的全部輸入。不過，您可以定義空位處理程式，來處理預期使用者在與節點互動時可能會詢問的自發問題。如需相關資訊，請參閱[新增空位](dialog-slots.html#add-slots)。

      下圖顯示如何配置脫離含空位的 #reservation 節點（如先前的圖解所示）。

      ![顯示與含空位的節點的脫離設定。](images/digress-away-slots-full.png)

    - **含空位的節點**：如果使用者選取**僅從容許返回的節點的空位脫離**勾選框來返回現行節點，請選擇是否只容許使用者脫離。

      若已選取，則對話尋找節點以回答使用者的無關問題時，會忽略未配置成在離題之後返回的全部根節點。如果您要避免使用者在完成填入必要空位之前永久地離開節點，請選取此勾選框。

    **離題到此節點**

    您可以針對離題到節點的運作方式進行下列選擇：

    - 避免使用者離題到節點。如需詳細資料，請參閱[停用離題到根節點](#diable-digressions)。

    - 若已啟用離題到節點，請選擇對話是否必須回到它所脫離的對話流程。若已選取，在處理現行節點的分支之後，對話流程會回到岔斷節點。若之後要讓對話返回，請選取**在離題之後返回**。

    下圖顯示如何配置離題到 #cuisine 節點（如先前的圖解所示）。

    ![顯示與含空位的節點的脫離設定。](images/digress-into-cuisine-full.png)

1.  按一下**套用**。

1.  使用「試用」窗格，以測試離題運作方式。

    同樣地，您無法定義離題的開始及結束。使用者可控制在何處及何時發生離題。您只能套用設定，用於判定單一節點如何參與離題。因為離題如此的無法預期，所以很難知道您的配置決策對整體交談的影響。若要真正得知所進行選擇的影響，您必須測試對話。

#reservation 及 #cuisine 節點代表兩個對話分支，可參與單一使用者指示的離題。針對每一個個別節點所配置的離題設定，即在執行時可能實現這類型離題的原因。

![顯示兩個對話，一個設定脫離 reservation 空位節點，另一個則設定離題到 cuisine 節點。](images/digression-settings.png)

### 停用離題到根節點
{: #disable-digressions}

流程離題到根節點時，會遵循針對該節點所配置的對話過程。因此，它可能會在到達節點分支尾端之前處理一系列的子節點，而且，如果配置為這樣做，則請回到已岔斷的對話流程。透過對話測試，您可能會發現根節點的觸發太過頻繁、或在未預期的時間觸發，或是其對話太過複雜，而導致使用者離題太遠無法成為良好的暫時離題候選。如果您決定不容許使用者離題到根節點，則可以將根節點配置成不容許離題進入。

若要完全停用離題到根節點，請完成下列步驟：

1.  按一下以開啟您要編輯的根節點。
1.  按一下**自訂**，然後按一下**離題**標籤。
1.  將*容許離題到此節點* 切換開關設為**關閉**。
1.  按一下**套用**。

如果您決定要避免離題到數個根節點，但不要個別編輯每一個根節點，則可以將數個節點新增至一個資料夾。從資料夾的*自訂* 頁面中，您可以將*容許離題到此節點* 切換開關設為**關閉**，一次將配置套用至所有節點。如需相關資訊，請參閱[使用資料夾組織對話](dialog-build.html#folders)。

### 設計考量
{: #digression-design-considerations}

- **避免備用節點大量生產**：許多對話設計程式都會在每個對話分支的尾端併入含 `true` 或 `anything_else` 條件的節點，以避免使用者停滯在分支中。如果使用者輸入不符合您的預期且包含要處理的特定對話節點，則此設計會傳回一般訊息。不過，使用者無法脫離使用此方式的對話流程。

  評估使用此方式的全部分支，以判定是否最好容許脫離分支。如果使用者輸入不符合您的預期，您可能會在樹狀結構中找到一個完全不同的對話流程。您可以有效地讓對話的其餘部分運作以嘗試處理使用者的輸入，而非回應一般訊息。而根層次 `Anything else` 節點一律可以回應其他根節點無法處理的輸入。

- **重新考慮跳至封閉式節點**：許多對話都設計成詢問標準封閉式問句，例如 `Did I answer your question today?`。使用者無法脫離配置成跳至另一個節點的節點。因此，如果您配置所有最終分支節點以跳至一般封閉式節點，離題並不會發生。請考慮透過度量值或一些其他方法來追蹤使用者滿意度。

- **測試可能的離題鏈**：如果使用者脫離現行節點到容許脫離的另一個節點，則使用者可能可以脫離這個其他節點，並重複此型樣一次以上。如果離題鏈中的所有節點都配置成在離題之後返回，則最後會將使用者帶回現行對話節點。不過，請測試下列情境：離題多次以判斷個別節點是否如預期運作。

- **記住現行節點的優先順序較高**：請記住，如果現行流程無法處理使用者輸入，則只會將現行流程外部的節點視為離題目標。更重要的是，含空位的節點容許脫離，具體而言是可讓使用者清楚瞭解他們需要提供的資訊，以及新增在使用者提供值之後顯示的確認陳述。

  在空位填入處理程序期間，可以填入任何空位。因此，空位可能會非預期地擷取使用者輸入。例如，含空位的節點可收集預約晚餐所需的資訊。其中一個空位收集日期資訊。提供預約詳細資料時，使用者可能會詢問 `What's the weather meant to be tomorrow?`。您的根節點可能會設定可回答使用者之 #forecast 的條件。不過，因為使用者輸入包含 `tomorrow` 這個字，並且正在處理含空位的預約節點，所以服務會假設使用者正在提供或更新預約日期。*現行節點的優先順序一律較高。* 如果您定義清楚的確認陳述（例如，`Ok, setting the reservation date to tomorrow`)，則使用者更有可能意識到發生誤解並會予以更正。

  反之，填入空位時，如果使用者提供的值不是任何空位預期的，則可能符合使用者永遠不會離題到其中的完全無關的根節點。

  配置離題運作時，請務必執行多次測試。

- **何時使用離題，而非空位處理程式**：針對使用者可能在任何時間詢問的一般問題，請使用容許離題到其中的根節點，處理輸入，然後回到進行中的流程。針對含空位的節點，請嘗試預期使用者可能會在填入空位時詢問的相關問題類型，並將處理程式新增至節點來進行處理。

  例如，如果含空位的節點收集填寫保險理賠所需的資訊，則您可能要新增可處理一般保險問題的處理程式。不過，針對如何取得協助的問題、儲存位置或公司歷程，請使用根層次節點。
